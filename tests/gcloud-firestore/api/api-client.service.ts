/**
 * This file is auto-generated by the API client generator.
 * https://github.com/flowup/api-client-generator
 *
 * Avoid editing this file manually unless necessary.
 * Please report any bugs so they can be addressed in future versions.
 */

/* tslint:disable */
/* eslint-disable */

import { HttpClient, HttpHeaders, HttpParams, HttpResponse, HttpEvent } from '@angular/common/http';
import { Inject, Injectable, InjectionToken, Optional } from '@angular/core';
import { APIClientInterface } from './api-client.interface';
import { Observable } from 'rxjs';import { DefaultHttpOptions, HttpOptions } from './types';

import * as models from './models';
export const USE_DOMAIN = new InjectionToken<string>('APIClient_USE_DOMAIN');
export const USE_HTTP_OPTIONS = new InjectionToken<HttpOptions>('APIClient_USE_HTTP_OPTIONS');

type APIHttpOptions = HttpOptions & {
  headers: HttpHeaders;
  params: HttpParams;
};

@Injectable()
export class APIClient implements APIClientInterface {

  readonly options: APIHttpOptions;

  readonly domain: string = `https://firestore.googleapis.com/v1beta1`;

  constructor(
    private readonly http: HttpClient,
    @Optional() @Inject(USE_DOMAIN) domain?: string,
    @Optional() @Inject(USE_HTTP_OPTIONS) options?: DefaultHttpOptions,
  ) {
    if (domain != null) {
      this.domain = domain;
    }

    this.options = {
      headers: new HttpHeaders(options && options.headers ? options.headers : {}),
      params: new HttpParams(options && options.params ? options.params : {}),
      ...(options && options.reportProgress ? { reportProgress: options.reportProgress } : {}),
      ...(options && options.withCredentials ? { withCredentials: options.withCredentials } : {})
    };
  }

  /**
   * Gets multiple documents.
   * 
   * 
   * Documents returned by this method are not guaranteed to be returned in the
   * same order that they were requested.
   * Response generated for [ 200 ] HTTP response code.
   */
  firestoreProjectsDatabasesDocumentsBatchGet(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesDocumentsBatchGetParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe?: 'body',
  ): Observable<models.BatchGetDocumentsResponse>;
  firestoreProjectsDatabasesDocumentsBatchGet(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesDocumentsBatchGetParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe?: 'response',
  ): Observable<HttpResponse<models.BatchGetDocumentsResponse>>;
  firestoreProjectsDatabasesDocumentsBatchGet(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesDocumentsBatchGetParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe?: 'events',
  ): Observable<HttpEvent<models.BatchGetDocumentsResponse>>;
  firestoreProjectsDatabasesDocumentsBatchGet(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesDocumentsBatchGetParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe: any = 'body',
  ): Observable<models.BatchGetDocumentsResponse | HttpResponse<models.BatchGetDocumentsResponse> | HttpEvent<models.BatchGetDocumentsResponse>> {
    const path = `/${args.database}/documents:batchGet`;
    const options = {
      ...this.options,
      ...requestHttpOptions,
      observe,
    };

    if ('$Xgafv' in args) {
      options.params = options.params.set('$.xgafv', String(args.$Xgafv));
    }
    if ('accessToken' in args) {
      options.params = options.params.set('access_token', String(args.accessToken));
    }
    if ('alt' in args) {
      options.params = options.params.set('alt', String(args.alt));
    }
    if ('bearerToken' in args) {
      options.params = options.params.set('bearer_token', String(args.bearerToken));
    }
    if ('callback' in args) {
      options.params = options.params.set('callback', String(args.callback));
    }
    if ('fields' in args) {
      options.params = options.params.set('fields', String(args.fields));
    }
    if ('key' in args) {
      options.params = options.params.set('key', String(args.key));
    }
    if ('oauthToken' in args) {
      options.params = options.params.set('oauth_token', String(args.oauthToken));
    }
    if ('pp' in args) {
      options.params = options.params.set('pp', String(args.pp));
    }
    if ('prettyPrint' in args) {
      options.params = options.params.set('prettyPrint', String(args.prettyPrint));
    }
    if ('quotaUser' in args) {
      options.params = options.params.set('quotaUser', String(args.quotaUser));
    }
    if ('uploadType' in args) {
      options.params = options.params.set('uploadType', String(args.uploadType));
    }
    if ('uploadProtocol' in args) {
      options.params = options.params.set('upload_protocol', String(args.uploadProtocol));
    }
    return this.http.post<models.BatchGetDocumentsResponse>(`${this.domain}${path}`, JSON.stringify(args.body), options);
  }

  /**
   * Starts a new transaction.
   * Response generated for [ 200 ] HTTP response code.
   */
  firestoreProjectsDatabasesDocumentsBeginTransaction(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesDocumentsBeginTransactionParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe?: 'body',
  ): Observable<models.BeginTransactionResponse>;
  firestoreProjectsDatabasesDocumentsBeginTransaction(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesDocumentsBeginTransactionParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe?: 'response',
  ): Observable<HttpResponse<models.BeginTransactionResponse>>;
  firestoreProjectsDatabasesDocumentsBeginTransaction(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesDocumentsBeginTransactionParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe?: 'events',
  ): Observable<HttpEvent<models.BeginTransactionResponse>>;
  firestoreProjectsDatabasesDocumentsBeginTransaction(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesDocumentsBeginTransactionParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe: any = 'body',
  ): Observable<models.BeginTransactionResponse | HttpResponse<models.BeginTransactionResponse> | HttpEvent<models.BeginTransactionResponse>> {
    const path = `/${args.database}/documents:beginTransaction`;
    const options = {
      ...this.options,
      ...requestHttpOptions,
      observe,
    };

    if ('$Xgafv' in args) {
      options.params = options.params.set('$.xgafv', String(args.$Xgafv));
    }
    if ('accessToken' in args) {
      options.params = options.params.set('access_token', String(args.accessToken));
    }
    if ('alt' in args) {
      options.params = options.params.set('alt', String(args.alt));
    }
    if ('bearerToken' in args) {
      options.params = options.params.set('bearer_token', String(args.bearerToken));
    }
    if ('callback' in args) {
      options.params = options.params.set('callback', String(args.callback));
    }
    if ('fields' in args) {
      options.params = options.params.set('fields', String(args.fields));
    }
    if ('key' in args) {
      options.params = options.params.set('key', String(args.key));
    }
    if ('oauthToken' in args) {
      options.params = options.params.set('oauth_token', String(args.oauthToken));
    }
    if ('pp' in args) {
      options.params = options.params.set('pp', String(args.pp));
    }
    if ('prettyPrint' in args) {
      options.params = options.params.set('prettyPrint', String(args.prettyPrint));
    }
    if ('quotaUser' in args) {
      options.params = options.params.set('quotaUser', String(args.quotaUser));
    }
    if ('uploadType' in args) {
      options.params = options.params.set('uploadType', String(args.uploadType));
    }
    if ('uploadProtocol' in args) {
      options.params = options.params.set('upload_protocol', String(args.uploadProtocol));
    }
    return this.http.post<models.BeginTransactionResponse>(`${this.domain}${path}`, JSON.stringify(args.body), options);
  }

  /**
   * Commits a transaction, while optionally updating documents.
   * Response generated for [ 200 ] HTTP response code.
   */
  firestoreProjectsDatabasesDocumentsCommit(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesDocumentsCommitParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe?: 'body',
  ): Observable<models.CommitResponse>;
  firestoreProjectsDatabasesDocumentsCommit(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesDocumentsCommitParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe?: 'response',
  ): Observable<HttpResponse<models.CommitResponse>>;
  firestoreProjectsDatabasesDocumentsCommit(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesDocumentsCommitParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe?: 'events',
  ): Observable<HttpEvent<models.CommitResponse>>;
  firestoreProjectsDatabasesDocumentsCommit(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesDocumentsCommitParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe: any = 'body',
  ): Observable<models.CommitResponse | HttpResponse<models.CommitResponse> | HttpEvent<models.CommitResponse>> {
    const path = `/${args.database}/documents:commit`;
    const options = {
      ...this.options,
      ...requestHttpOptions,
      observe,
    };

    if ('$Xgafv' in args) {
      options.params = options.params.set('$.xgafv', String(args.$Xgafv));
    }
    if ('accessToken' in args) {
      options.params = options.params.set('access_token', String(args.accessToken));
    }
    if ('alt' in args) {
      options.params = options.params.set('alt', String(args.alt));
    }
    if ('bearerToken' in args) {
      options.params = options.params.set('bearer_token', String(args.bearerToken));
    }
    if ('callback' in args) {
      options.params = options.params.set('callback', String(args.callback));
    }
    if ('fields' in args) {
      options.params = options.params.set('fields', String(args.fields));
    }
    if ('key' in args) {
      options.params = options.params.set('key', String(args.key));
    }
    if ('oauthToken' in args) {
      options.params = options.params.set('oauth_token', String(args.oauthToken));
    }
    if ('pp' in args) {
      options.params = options.params.set('pp', String(args.pp));
    }
    if ('prettyPrint' in args) {
      options.params = options.params.set('prettyPrint', String(args.prettyPrint));
    }
    if ('quotaUser' in args) {
      options.params = options.params.set('quotaUser', String(args.quotaUser));
    }
    if ('uploadType' in args) {
      options.params = options.params.set('uploadType', String(args.uploadType));
    }
    if ('uploadProtocol' in args) {
      options.params = options.params.set('upload_protocol', String(args.uploadProtocol));
    }
    return this.http.post<models.CommitResponse>(`${this.domain}${path}`, JSON.stringify(args.body), options);
  }

  /**
   * Listens to changes.
   * Response generated for [ 200 ] HTTP response code.
   */
  firestoreProjectsDatabasesDocumentsListen(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesDocumentsListenParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe?: 'body',
  ): Observable<models.ListenResponse>;
  firestoreProjectsDatabasesDocumentsListen(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesDocumentsListenParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe?: 'response',
  ): Observable<HttpResponse<models.ListenResponse>>;
  firestoreProjectsDatabasesDocumentsListen(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesDocumentsListenParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe?: 'events',
  ): Observable<HttpEvent<models.ListenResponse>>;
  firestoreProjectsDatabasesDocumentsListen(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesDocumentsListenParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe: any = 'body',
  ): Observable<models.ListenResponse | HttpResponse<models.ListenResponse> | HttpEvent<models.ListenResponse>> {
    const path = `/${args.database}/documents:listen`;
    const options = {
      ...this.options,
      ...requestHttpOptions,
      observe,
    };

    if ('$Xgafv' in args) {
      options.params = options.params.set('$.xgafv', String(args.$Xgafv));
    }
    if ('accessToken' in args) {
      options.params = options.params.set('access_token', String(args.accessToken));
    }
    if ('alt' in args) {
      options.params = options.params.set('alt', String(args.alt));
    }
    if ('bearerToken' in args) {
      options.params = options.params.set('bearer_token', String(args.bearerToken));
    }
    if ('callback' in args) {
      options.params = options.params.set('callback', String(args.callback));
    }
    if ('fields' in args) {
      options.params = options.params.set('fields', String(args.fields));
    }
    if ('key' in args) {
      options.params = options.params.set('key', String(args.key));
    }
    if ('oauthToken' in args) {
      options.params = options.params.set('oauth_token', String(args.oauthToken));
    }
    if ('pp' in args) {
      options.params = options.params.set('pp', String(args.pp));
    }
    if ('prettyPrint' in args) {
      options.params = options.params.set('prettyPrint', String(args.prettyPrint));
    }
    if ('quotaUser' in args) {
      options.params = options.params.set('quotaUser', String(args.quotaUser));
    }
    if ('uploadType' in args) {
      options.params = options.params.set('uploadType', String(args.uploadType));
    }
    if ('uploadProtocol' in args) {
      options.params = options.params.set('upload_protocol', String(args.uploadProtocol));
    }
    return this.http.post<models.ListenResponse>(`${this.domain}${path}`, JSON.stringify(args.body), options);
  }

  /**
   * Rolls back a transaction.
   * Response generated for [ 200 ] HTTP response code.
   */
  firestoreProjectsDatabasesDocumentsRollback(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesDocumentsRollbackParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe?: 'body',
  ): Observable<models.Empty>;
  firestoreProjectsDatabasesDocumentsRollback(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesDocumentsRollbackParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe?: 'response',
  ): Observable<HttpResponse<models.Empty>>;
  firestoreProjectsDatabasesDocumentsRollback(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesDocumentsRollbackParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe?: 'events',
  ): Observable<HttpEvent<models.Empty>>;
  firestoreProjectsDatabasesDocumentsRollback(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesDocumentsRollbackParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe: any = 'body',
  ): Observable<models.Empty | HttpResponse<models.Empty> | HttpEvent<models.Empty>> {
    const path = `/${args.database}/documents:rollback`;
    const options = {
      ...this.options,
      ...requestHttpOptions,
      observe,
    };

    if ('$Xgafv' in args) {
      options.params = options.params.set('$.xgafv', String(args.$Xgafv));
    }
    if ('accessToken' in args) {
      options.params = options.params.set('access_token', String(args.accessToken));
    }
    if ('alt' in args) {
      options.params = options.params.set('alt', String(args.alt));
    }
    if ('bearerToken' in args) {
      options.params = options.params.set('bearer_token', String(args.bearerToken));
    }
    if ('callback' in args) {
      options.params = options.params.set('callback', String(args.callback));
    }
    if ('fields' in args) {
      options.params = options.params.set('fields', String(args.fields));
    }
    if ('key' in args) {
      options.params = options.params.set('key', String(args.key));
    }
    if ('oauthToken' in args) {
      options.params = options.params.set('oauth_token', String(args.oauthToken));
    }
    if ('pp' in args) {
      options.params = options.params.set('pp', String(args.pp));
    }
    if ('prettyPrint' in args) {
      options.params = options.params.set('prettyPrint', String(args.prettyPrint));
    }
    if ('quotaUser' in args) {
      options.params = options.params.set('quotaUser', String(args.quotaUser));
    }
    if ('uploadType' in args) {
      options.params = options.params.set('uploadType', String(args.uploadType));
    }
    if ('uploadProtocol' in args) {
      options.params = options.params.set('upload_protocol', String(args.uploadProtocol));
    }
    return this.http.post<models.Empty>(`${this.domain}${path}`, JSON.stringify(args.body), options);
  }

  /**
   * Streams batches of document updates and deletes, in order.
   * Response generated for [ 200 ] HTTP response code.
   */
  firestoreProjectsDatabasesDocumentsWrite(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesDocumentsWriteParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe?: 'body',
  ): Observable<models.WriteResponse>;
  firestoreProjectsDatabasesDocumentsWrite(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesDocumentsWriteParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe?: 'response',
  ): Observable<HttpResponse<models.WriteResponse>>;
  firestoreProjectsDatabasesDocumentsWrite(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesDocumentsWriteParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe?: 'events',
  ): Observable<HttpEvent<models.WriteResponse>>;
  firestoreProjectsDatabasesDocumentsWrite(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesDocumentsWriteParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe: any = 'body',
  ): Observable<models.WriteResponse | HttpResponse<models.WriteResponse> | HttpEvent<models.WriteResponse>> {
    const path = `/${args.database}/documents:write`;
    const options = {
      ...this.options,
      ...requestHttpOptions,
      observe,
    };

    if ('$Xgafv' in args) {
      options.params = options.params.set('$.xgafv', String(args.$Xgafv));
    }
    if ('accessToken' in args) {
      options.params = options.params.set('access_token', String(args.accessToken));
    }
    if ('alt' in args) {
      options.params = options.params.set('alt', String(args.alt));
    }
    if ('bearerToken' in args) {
      options.params = options.params.set('bearer_token', String(args.bearerToken));
    }
    if ('callback' in args) {
      options.params = options.params.set('callback', String(args.callback));
    }
    if ('fields' in args) {
      options.params = options.params.set('fields', String(args.fields));
    }
    if ('key' in args) {
      options.params = options.params.set('key', String(args.key));
    }
    if ('oauthToken' in args) {
      options.params = options.params.set('oauth_token', String(args.oauthToken));
    }
    if ('pp' in args) {
      options.params = options.params.set('pp', String(args.pp));
    }
    if ('prettyPrint' in args) {
      options.params = options.params.set('prettyPrint', String(args.prettyPrint));
    }
    if ('quotaUser' in args) {
      options.params = options.params.set('quotaUser', String(args.quotaUser));
    }
    if ('uploadType' in args) {
      options.params = options.params.set('uploadType', String(args.uploadType));
    }
    if ('uploadProtocol' in args) {
      options.params = options.params.set('upload_protocol', String(args.uploadProtocol));
    }
    return this.http.post<models.WriteResponse>(`${this.domain}${path}`, JSON.stringify(args.body), options);
  }

  /**
   * Deletes an index.
   * Response generated for [ 200 ] HTTP response code.
   */
  firestoreProjectsDatabasesIndexesDelete(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesIndexesDeleteParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe?: 'body',
  ): Observable<models.Empty>;
  firestoreProjectsDatabasesIndexesDelete(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesIndexesDeleteParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe?: 'response',
  ): Observable<HttpResponse<models.Empty>>;
  firestoreProjectsDatabasesIndexesDelete(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesIndexesDeleteParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe?: 'events',
  ): Observable<HttpEvent<models.Empty>>;
  firestoreProjectsDatabasesIndexesDelete(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesIndexesDeleteParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe: any = 'body',
  ): Observable<models.Empty | HttpResponse<models.Empty> | HttpEvent<models.Empty>> {
    const path = `/${args.name}`;
    const options = {
      ...this.options,
      ...requestHttpOptions,
      observe,
    };

    if ('$Xgafv' in args) {
      options.params = options.params.set('$.xgafv', String(args.$Xgafv));
    }
    if ('accessToken' in args) {
      options.params = options.params.set('access_token', String(args.accessToken));
    }
    if ('alt' in args) {
      options.params = options.params.set('alt', String(args.alt));
    }
    if ('bearerToken' in args) {
      options.params = options.params.set('bearer_token', String(args.bearerToken));
    }
    if ('callback' in args) {
      options.params = options.params.set('callback', String(args.callback));
    }
    if ('fields' in args) {
      options.params = options.params.set('fields', String(args.fields));
    }
    if ('key' in args) {
      options.params = options.params.set('key', String(args.key));
    }
    if ('oauthToken' in args) {
      options.params = options.params.set('oauth_token', String(args.oauthToken));
    }
    if ('pp' in args) {
      options.params = options.params.set('pp', String(args.pp));
    }
    if ('prettyPrint' in args) {
      options.params = options.params.set('prettyPrint', String(args.prettyPrint));
    }
    if ('quotaUser' in args) {
      options.params = options.params.set('quotaUser', String(args.quotaUser));
    }
    if ('uploadType' in args) {
      options.params = options.params.set('uploadType', String(args.uploadType));
    }
    if ('uploadProtocol' in args) {
      options.params = options.params.set('upload_protocol', String(args.uploadProtocol));
    }
    if ('currentDocumentExists' in args) {
      options.params = options.params.set('currentDocument.exists', String(args.currentDocumentExists));
    }
    if ('currentDocumentUpdateTime' in args) {
      options.params = options.params.set('currentDocument.updateTime', String(args.currentDocumentUpdateTime));
    }
    return this.http.delete<models.Empty>(`${this.domain}${path}`, options);
  }

  /**
   * Gets an index.
   * Response generated for [ 200 ] HTTP response code.
   */
  firestoreProjectsDatabasesIndexesGet(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesIndexesGetParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe?: 'body',
  ): Observable<models.Index>;
  firestoreProjectsDatabasesIndexesGet(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesIndexesGetParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe?: 'response',
  ): Observable<HttpResponse<models.Index>>;
  firestoreProjectsDatabasesIndexesGet(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesIndexesGetParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe?: 'events',
  ): Observable<HttpEvent<models.Index>>;
  firestoreProjectsDatabasesIndexesGet(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesIndexesGetParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe: any = 'body',
  ): Observable<models.Index | HttpResponse<models.Index> | HttpEvent<models.Index>> {
    const path = `/${args.name}`;
    const options = {
      ...this.options,
      ...requestHttpOptions,
      observe,
    };

    if ('$Xgafv' in args) {
      options.params = options.params.set('$.xgafv', String(args.$Xgafv));
    }
    if ('accessToken' in args) {
      options.params = options.params.set('access_token', String(args.accessToken));
    }
    if ('alt' in args) {
      options.params = options.params.set('alt', String(args.alt));
    }
    if ('bearerToken' in args) {
      options.params = options.params.set('bearer_token', String(args.bearerToken));
    }
    if ('callback' in args) {
      options.params = options.params.set('callback', String(args.callback));
    }
    if ('fields' in args) {
      options.params = options.params.set('fields', String(args.fields));
    }
    if ('key' in args) {
      options.params = options.params.set('key', String(args.key));
    }
    if ('oauthToken' in args) {
      options.params = options.params.set('oauth_token', String(args.oauthToken));
    }
    if ('pp' in args) {
      options.params = options.params.set('pp', String(args.pp));
    }
    if ('prettyPrint' in args) {
      options.params = options.params.set('prettyPrint', String(args.prettyPrint));
    }
    if ('quotaUser' in args) {
      options.params = options.params.set('quotaUser', String(args.quotaUser));
    }
    if ('uploadType' in args) {
      options.params = options.params.set('uploadType', String(args.uploadType));
    }
    if ('uploadProtocol' in args) {
      options.params = options.params.set('upload_protocol', String(args.uploadProtocol));
    }
    if ('maskFieldPaths' in args) {
      options.params = options.params.set('mask.fieldPaths', String(args.maskFieldPaths));
    }
    if ('readTime' in args) {
      options.params = options.params.set('readTime', String(args.readTime));
    }
    if ('transaction' in args) {
      options.params = options.params.set('transaction', String(args.transaction));
    }
    return this.http.get<models.Index>(`${this.domain}${path}`, options);
  }

  /**
   * Updates or inserts a document.
   * Response generated for [ 200 ] HTTP response code.
   */
  firestoreProjectsDatabasesDocumentsPatch(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesDocumentsPatchParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe?: 'body',
  ): Observable<models.Document>;
  firestoreProjectsDatabasesDocumentsPatch(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesDocumentsPatchParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe?: 'response',
  ): Observable<HttpResponse<models.Document>>;
  firestoreProjectsDatabasesDocumentsPatch(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesDocumentsPatchParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe?: 'events',
  ): Observable<HttpEvent<models.Document>>;
  firestoreProjectsDatabasesDocumentsPatch(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesDocumentsPatchParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe: any = 'body',
  ): Observable<models.Document | HttpResponse<models.Document> | HttpEvent<models.Document>> {
    const path = `/${args.name}`;
    const options = {
      ...this.options,
      ...requestHttpOptions,
      observe,
    };

    if ('$Xgafv' in args) {
      options.params = options.params.set('$.xgafv', String(args.$Xgafv));
    }
    if ('accessToken' in args) {
      options.params = options.params.set('access_token', String(args.accessToken));
    }
    if ('alt' in args) {
      options.params = options.params.set('alt', String(args.alt));
    }
    if ('bearerToken' in args) {
      options.params = options.params.set('bearer_token', String(args.bearerToken));
    }
    if ('callback' in args) {
      options.params = options.params.set('callback', String(args.callback));
    }
    if ('fields' in args) {
      options.params = options.params.set('fields', String(args.fields));
    }
    if ('key' in args) {
      options.params = options.params.set('key', String(args.key));
    }
    if ('oauthToken' in args) {
      options.params = options.params.set('oauth_token', String(args.oauthToken));
    }
    if ('pp' in args) {
      options.params = options.params.set('pp', String(args.pp));
    }
    if ('prettyPrint' in args) {
      options.params = options.params.set('prettyPrint', String(args.prettyPrint));
    }
    if ('quotaUser' in args) {
      options.params = options.params.set('quotaUser', String(args.quotaUser));
    }
    if ('uploadType' in args) {
      options.params = options.params.set('uploadType', String(args.uploadType));
    }
    if ('uploadProtocol' in args) {
      options.params = options.params.set('upload_protocol', String(args.uploadProtocol));
    }
    if ('currentDocumentExists' in args) {
      options.params = options.params.set('currentDocument.exists', String(args.currentDocumentExists));
    }
    if ('currentDocumentUpdateTime' in args) {
      options.params = options.params.set('currentDocument.updateTime', String(args.currentDocumentUpdateTime));
    }
    if ('maskFieldPaths' in args) {
      options.params = options.params.set('mask.fieldPaths', String(args.maskFieldPaths));
    }
    if ('updateMaskFieldPaths' in args) {
      options.params = options.params.set('updateMask.fieldPaths', String(args.updateMaskFieldPaths));
    }
    return this.http.patch<models.Document>(`${this.domain}${path}`, JSON.stringify(args.body), options);
  }

  /**
   * Lists the indexes that match the specified filters.
   * Response generated for [ 200 ] HTTP response code.
   */
  firestoreProjectsDatabasesIndexesList(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesIndexesListParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe?: 'body',
  ): Observable<models.ListIndexesResponse>;
  firestoreProjectsDatabasesIndexesList(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesIndexesListParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe?: 'response',
  ): Observable<HttpResponse<models.ListIndexesResponse>>;
  firestoreProjectsDatabasesIndexesList(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesIndexesListParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe?: 'events',
  ): Observable<HttpEvent<models.ListIndexesResponse>>;
  firestoreProjectsDatabasesIndexesList(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesIndexesListParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe: any = 'body',
  ): Observable<models.ListIndexesResponse | HttpResponse<models.ListIndexesResponse> | HttpEvent<models.ListIndexesResponse>> {
    const path = `/${args.parent}/indexes`;
    const options = {
      ...this.options,
      ...requestHttpOptions,
      observe,
    };

    if ('$Xgafv' in args) {
      options.params = options.params.set('$.xgafv', String(args.$Xgafv));
    }
    if ('accessToken' in args) {
      options.params = options.params.set('access_token', String(args.accessToken));
    }
    if ('alt' in args) {
      options.params = options.params.set('alt', String(args.alt));
    }
    if ('bearerToken' in args) {
      options.params = options.params.set('bearer_token', String(args.bearerToken));
    }
    if ('callback' in args) {
      options.params = options.params.set('callback', String(args.callback));
    }
    if ('fields' in args) {
      options.params = options.params.set('fields', String(args.fields));
    }
    if ('key' in args) {
      options.params = options.params.set('key', String(args.key));
    }
    if ('oauthToken' in args) {
      options.params = options.params.set('oauth_token', String(args.oauthToken));
    }
    if ('pp' in args) {
      options.params = options.params.set('pp', String(args.pp));
    }
    if ('prettyPrint' in args) {
      options.params = options.params.set('prettyPrint', String(args.prettyPrint));
    }
    if ('quotaUser' in args) {
      options.params = options.params.set('quotaUser', String(args.quotaUser));
    }
    if ('uploadType' in args) {
      options.params = options.params.set('uploadType', String(args.uploadType));
    }
    if ('uploadProtocol' in args) {
      options.params = options.params.set('upload_protocol', String(args.uploadProtocol));
    }
    if ('filter' in args) {
      options.params = options.params.set('filter', String(args.filter));
    }
    if ('pageSize' in args) {
      options.params = options.params.set('pageSize', String(args.pageSize));
    }
    if ('pageToken' in args) {
      options.params = options.params.set('pageToken', String(args.pageToken));
    }
    return this.http.get<models.ListIndexesResponse>(`${this.domain}${path}`, options);
  }

  /**
   * Creates the specified index.
   * A newly created index's initial state is `CREATING`. On completion of the
   * returned google.longrunning.Operation, the state will be `READY`.
   * If the index already exists, the call will return an `ALREADY_EXISTS`
   * status.
   * 
   * 
   * During creation, the process could result in an error, in which case the
   * index will move to the `ERROR` state. The process can be recovered by
   * fixing the data that caused the error, removing the index with
   * delete, then re-creating the index with
   * create.
   * 
   * 
   * Indexes with a single field cannot be created.
   * Response generated for [ 200 ] HTTP response code.
   */
  firestoreProjectsDatabasesIndexesCreate(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesIndexesCreateParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe?: 'body',
  ): Observable<models.Operation>;
  firestoreProjectsDatabasesIndexesCreate(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesIndexesCreateParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe?: 'response',
  ): Observable<HttpResponse<models.Operation>>;
  firestoreProjectsDatabasesIndexesCreate(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesIndexesCreateParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe?: 'events',
  ): Observable<HttpEvent<models.Operation>>;
  firestoreProjectsDatabasesIndexesCreate(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesIndexesCreateParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe: any = 'body',
  ): Observable<models.Operation | HttpResponse<models.Operation> | HttpEvent<models.Operation>> {
    const path = `/${args.parent}/indexes`;
    const options = {
      ...this.options,
      ...requestHttpOptions,
      observe,
    };

    if ('$Xgafv' in args) {
      options.params = options.params.set('$.xgafv', String(args.$Xgafv));
    }
    if ('accessToken' in args) {
      options.params = options.params.set('access_token', String(args.accessToken));
    }
    if ('alt' in args) {
      options.params = options.params.set('alt', String(args.alt));
    }
    if ('bearerToken' in args) {
      options.params = options.params.set('bearer_token', String(args.bearerToken));
    }
    if ('callback' in args) {
      options.params = options.params.set('callback', String(args.callback));
    }
    if ('fields' in args) {
      options.params = options.params.set('fields', String(args.fields));
    }
    if ('key' in args) {
      options.params = options.params.set('key', String(args.key));
    }
    if ('oauthToken' in args) {
      options.params = options.params.set('oauth_token', String(args.oauthToken));
    }
    if ('pp' in args) {
      options.params = options.params.set('pp', String(args.pp));
    }
    if ('prettyPrint' in args) {
      options.params = options.params.set('prettyPrint', String(args.prettyPrint));
    }
    if ('quotaUser' in args) {
      options.params = options.params.set('quotaUser', String(args.quotaUser));
    }
    if ('uploadType' in args) {
      options.params = options.params.set('uploadType', String(args.uploadType));
    }
    if ('uploadProtocol' in args) {
      options.params = options.params.set('upload_protocol', String(args.uploadProtocol));
    }
    return this.http.post<models.Operation>(`${this.domain}${path}`, JSON.stringify(args.body), options);
  }

  /**
   * Lists documents.
   * Response generated for [ 200 ] HTTP response code.
   */
  firestoreProjectsDatabasesDocumentsList(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesDocumentsListParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe?: 'body',
  ): Observable<models.ListDocumentsResponse>;
  firestoreProjectsDatabasesDocumentsList(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesDocumentsListParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe?: 'response',
  ): Observable<HttpResponse<models.ListDocumentsResponse>>;
  firestoreProjectsDatabasesDocumentsList(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesDocumentsListParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe?: 'events',
  ): Observable<HttpEvent<models.ListDocumentsResponse>>;
  firestoreProjectsDatabasesDocumentsList(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesDocumentsListParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe: any = 'body',
  ): Observable<models.ListDocumentsResponse | HttpResponse<models.ListDocumentsResponse> | HttpEvent<models.ListDocumentsResponse>> {
    const path = `/${args.parent}/${args.collectionId}`;
    const options = {
      ...this.options,
      ...requestHttpOptions,
      observe,
    };

    if ('$Xgafv' in args) {
      options.params = options.params.set('$.xgafv', String(args.$Xgafv));
    }
    if ('accessToken' in args) {
      options.params = options.params.set('access_token', String(args.accessToken));
    }
    if ('alt' in args) {
      options.params = options.params.set('alt', String(args.alt));
    }
    if ('bearerToken' in args) {
      options.params = options.params.set('bearer_token', String(args.bearerToken));
    }
    if ('callback' in args) {
      options.params = options.params.set('callback', String(args.callback));
    }
    if ('fields' in args) {
      options.params = options.params.set('fields', String(args.fields));
    }
    if ('key' in args) {
      options.params = options.params.set('key', String(args.key));
    }
    if ('oauthToken' in args) {
      options.params = options.params.set('oauth_token', String(args.oauthToken));
    }
    if ('pp' in args) {
      options.params = options.params.set('pp', String(args.pp));
    }
    if ('prettyPrint' in args) {
      options.params = options.params.set('prettyPrint', String(args.prettyPrint));
    }
    if ('quotaUser' in args) {
      options.params = options.params.set('quotaUser', String(args.quotaUser));
    }
    if ('uploadType' in args) {
      options.params = options.params.set('uploadType', String(args.uploadType));
    }
    if ('uploadProtocol' in args) {
      options.params = options.params.set('upload_protocol', String(args.uploadProtocol));
    }
    if ('maskFieldPaths' in args) {
      options.params = options.params.set('mask.fieldPaths', String(args.maskFieldPaths));
    }
    if ('orderBy' in args) {
      options.params = options.params.set('orderBy', String(args.orderBy));
    }
    if ('pageSize' in args) {
      options.params = options.params.set('pageSize', String(args.pageSize));
    }
    if ('pageToken' in args) {
      options.params = options.params.set('pageToken', String(args.pageToken));
    }
    if ('readTime' in args) {
      options.params = options.params.set('readTime', String(args.readTime));
    }
    if ('showMissing' in args) {
      options.params = options.params.set('showMissing', String(args.showMissing));
    }
    if ('transaction' in args) {
      options.params = options.params.set('transaction', String(args.transaction));
    }
    return this.http.get<models.ListDocumentsResponse>(`${this.domain}${path}`, options);
  }

  /**
   * Creates a new document.
   * Response generated for [ 200 ] HTTP response code.
   */
  firestoreProjectsDatabasesDocumentsCreateDocument(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesDocumentsCreateDocumentParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe?: 'body',
  ): Observable<models.Document>;
  firestoreProjectsDatabasesDocumentsCreateDocument(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesDocumentsCreateDocumentParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe?: 'response',
  ): Observable<HttpResponse<models.Document>>;
  firestoreProjectsDatabasesDocumentsCreateDocument(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesDocumentsCreateDocumentParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe?: 'events',
  ): Observable<HttpEvent<models.Document>>;
  firestoreProjectsDatabasesDocumentsCreateDocument(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesDocumentsCreateDocumentParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe: any = 'body',
  ): Observable<models.Document | HttpResponse<models.Document> | HttpEvent<models.Document>> {
    const path = `/${args.parent}/${args.collectionId}`;
    const options = {
      ...this.options,
      ...requestHttpOptions,
      observe,
    };

    if ('$Xgafv' in args) {
      options.params = options.params.set('$.xgafv', String(args.$Xgafv));
    }
    if ('accessToken' in args) {
      options.params = options.params.set('access_token', String(args.accessToken));
    }
    if ('alt' in args) {
      options.params = options.params.set('alt', String(args.alt));
    }
    if ('bearerToken' in args) {
      options.params = options.params.set('bearer_token', String(args.bearerToken));
    }
    if ('callback' in args) {
      options.params = options.params.set('callback', String(args.callback));
    }
    if ('fields' in args) {
      options.params = options.params.set('fields', String(args.fields));
    }
    if ('key' in args) {
      options.params = options.params.set('key', String(args.key));
    }
    if ('oauthToken' in args) {
      options.params = options.params.set('oauth_token', String(args.oauthToken));
    }
    if ('pp' in args) {
      options.params = options.params.set('pp', String(args.pp));
    }
    if ('prettyPrint' in args) {
      options.params = options.params.set('prettyPrint', String(args.prettyPrint));
    }
    if ('quotaUser' in args) {
      options.params = options.params.set('quotaUser', String(args.quotaUser));
    }
    if ('uploadType' in args) {
      options.params = options.params.set('uploadType', String(args.uploadType));
    }
    if ('uploadProtocol' in args) {
      options.params = options.params.set('upload_protocol', String(args.uploadProtocol));
    }
    if ('documentId' in args) {
      options.params = options.params.set('documentId', String(args.documentId));
    }
    if ('maskFieldPaths' in args) {
      options.params = options.params.set('mask.fieldPaths', String(args.maskFieldPaths));
    }
    return this.http.post<models.Document>(`${this.domain}${path}`, JSON.stringify(args.body), options);
  }

  /**
   * Lists all the collection IDs underneath a document.
   * Response generated for [ 200 ] HTTP response code.
   */
  firestoreProjectsDatabasesDocumentsListCollectionIds(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesDocumentsListCollectionIdsParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe?: 'body',
  ): Observable<models.ListCollectionIdsResponse>;
  firestoreProjectsDatabasesDocumentsListCollectionIds(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesDocumentsListCollectionIdsParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe?: 'response',
  ): Observable<HttpResponse<models.ListCollectionIdsResponse>>;
  firestoreProjectsDatabasesDocumentsListCollectionIds(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesDocumentsListCollectionIdsParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe?: 'events',
  ): Observable<HttpEvent<models.ListCollectionIdsResponse>>;
  firestoreProjectsDatabasesDocumentsListCollectionIds(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesDocumentsListCollectionIdsParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe: any = 'body',
  ): Observable<models.ListCollectionIdsResponse | HttpResponse<models.ListCollectionIdsResponse> | HttpEvent<models.ListCollectionIdsResponse>> {
    const path = `/${args.parent}:listCollectionIds`;
    const options = {
      ...this.options,
      ...requestHttpOptions,
      observe,
    };

    if ('$Xgafv' in args) {
      options.params = options.params.set('$.xgafv', String(args.$Xgafv));
    }
    if ('accessToken' in args) {
      options.params = options.params.set('access_token', String(args.accessToken));
    }
    if ('alt' in args) {
      options.params = options.params.set('alt', String(args.alt));
    }
    if ('bearerToken' in args) {
      options.params = options.params.set('bearer_token', String(args.bearerToken));
    }
    if ('callback' in args) {
      options.params = options.params.set('callback', String(args.callback));
    }
    if ('fields' in args) {
      options.params = options.params.set('fields', String(args.fields));
    }
    if ('key' in args) {
      options.params = options.params.set('key', String(args.key));
    }
    if ('oauthToken' in args) {
      options.params = options.params.set('oauth_token', String(args.oauthToken));
    }
    if ('pp' in args) {
      options.params = options.params.set('pp', String(args.pp));
    }
    if ('prettyPrint' in args) {
      options.params = options.params.set('prettyPrint', String(args.prettyPrint));
    }
    if ('quotaUser' in args) {
      options.params = options.params.set('quotaUser', String(args.quotaUser));
    }
    if ('uploadType' in args) {
      options.params = options.params.set('uploadType', String(args.uploadType));
    }
    if ('uploadProtocol' in args) {
      options.params = options.params.set('upload_protocol', String(args.uploadProtocol));
    }
    return this.http.post<models.ListCollectionIdsResponse>(`${this.domain}${path}`, JSON.stringify(args.body), options);
  }

  /**
   * Runs a query.
   * Response generated for [ 200 ] HTTP response code.
   */
  firestoreProjectsDatabasesDocumentsRunQuery(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesDocumentsRunQueryParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe?: 'body',
  ): Observable<models.RunQueryResponse>;
  firestoreProjectsDatabasesDocumentsRunQuery(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesDocumentsRunQueryParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe?: 'response',
  ): Observable<HttpResponse<models.RunQueryResponse>>;
  firestoreProjectsDatabasesDocumentsRunQuery(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesDocumentsRunQueryParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe?: 'events',
  ): Observable<HttpEvent<models.RunQueryResponse>>;
  firestoreProjectsDatabasesDocumentsRunQuery(
    args: Exclude<APIClientInterface['firestoreProjectsDatabasesDocumentsRunQueryParams'], undefined>,
    requestHttpOptions?: HttpOptions,
    observe: any = 'body',
  ): Observable<models.RunQueryResponse | HttpResponse<models.RunQueryResponse> | HttpEvent<models.RunQueryResponse>> {
    const path = `/${args.parent}:runQuery`;
    const options = {
      ...this.options,
      ...requestHttpOptions,
      observe,
    };

    if ('$Xgafv' in args) {
      options.params = options.params.set('$.xgafv', String(args.$Xgafv));
    }
    if ('accessToken' in args) {
      options.params = options.params.set('access_token', String(args.accessToken));
    }
    if ('alt' in args) {
      options.params = options.params.set('alt', String(args.alt));
    }
    if ('bearerToken' in args) {
      options.params = options.params.set('bearer_token', String(args.bearerToken));
    }
    if ('callback' in args) {
      options.params = options.params.set('callback', String(args.callback));
    }
    if ('fields' in args) {
      options.params = options.params.set('fields', String(args.fields));
    }
    if ('key' in args) {
      options.params = options.params.set('key', String(args.key));
    }
    if ('oauthToken' in args) {
      options.params = options.params.set('oauth_token', String(args.oauthToken));
    }
    if ('pp' in args) {
      options.params = options.params.set('pp', String(args.pp));
    }
    if ('prettyPrint' in args) {
      options.params = options.params.set('prettyPrint', String(args.prettyPrint));
    }
    if ('quotaUser' in args) {
      options.params = options.params.set('quotaUser', String(args.quotaUser));
    }
    if ('uploadType' in args) {
      options.params = options.params.set('uploadType', String(args.uploadType));
    }
    if ('uploadProtocol' in args) {
      options.params = options.params.set('upload_protocol', String(args.uploadProtocol));
    }
    return this.http.post<models.RunQueryResponse>(`${this.domain}${path}`, JSON.stringify(args.body), options);
  }

}
